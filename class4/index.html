<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<script type="text/javascript">
		// 代码执行之前的时候，就会创建一个全局的执行上下文 Clobal Excution Context
		// 创建完了全剧的执行上下文之后，把全剧执行上下文压入执行环境中，后压入的先执行

		function fn1 () {
			fn2 ();
			// fn2执行完成之后，fn1才会执行完毕。

		};

		function fn2 () {
			// 先执行
		};

		fn1();

		// 函数执行期上下文生命周期
		// 函数执行上下文（CES）
		// 1. 创建 
		// 1.1 生成变量对象
		// 1.2 建立作用域链
		// 1.3 确定this指向
		// 2. 执行
		// 2.1 变量赋值
		// 2.2 函数引用
		// 2.3 执行其他代码
		// 3. 执行完毕出栈，等待被回收。 

		// 4.创建阶段
		// 4.1 创建作用域链（Scope Chain）
		// 4.2 创建变量对象（或者AO）：首先初始化函数的参数arguments，初始化函数声明，初始化变量（undefeated）。函数的优先级要高于变量，如果变量和函数重名，变量会被忽略。
		// 4.3 创建arguments对象，检查上下文，初始化参数名称和值并创建引用的复制。
		// 4.4 扫描上下文的函数声明（而非函数表达式）
		// 为发现的每一个函数，在变量对象上创建一个属性————确切的说是函数的名字，汽油一个指向函数在内存中的引用。
		// 如果函数的名字已经存在，引用指针将被重写。
		// 4.5 扫描上下文的变量声明
		// 为发现的每个变量声明，在变量对象上创建一个属性————就是变量的名字，并且将变量的值初始化为undefeated。
		// 如果变量的名字已经在比那两对象里存在，将不会进行任何操作并继续扫描。
		// 4.6 求出上下文内部“this”指向。

		// 5.创建的阶段
		// 5.1 执行变量赋值、代码执行
		// 6. 回收阶段
		// 6.1 执行上下文出栈等待虚拟机回收执行上下文。

		// 7.作用域
		// 作用域:就是变量声明的区域，就是变量和函数的可访问范围，在全局声明的变量为全局可见可访问的就是全局变量，如果在函数内部声明的变量只能在函数内部访问。 
		// 函数的参数只能在函数内部访问，是局部变量
		// JavaScript没有块级作用域。只有函数作用域和全局作用域。for循环内部定义的变量是函数级别的作用域。外部访问。
		// 变量没有在函数内声明或者声明的时候没有带var就是全局比那两，拥有全局作用域。特殊var a = b = c =0;b、c是全局变量。
		// 全局作用域的变量可以在js中任何地方调用，函数作用域的变量只能在自己函数内部调用，包括自己内部定义的其他函数都可以直接调用。
		// 变量的作用域是以它声明时的为准，因为变量的作用域在JS代码的解释阶段就已经完成规则的制定。
		

		// JavaScript没有块级作用域
		// for循环、while循环中定义的变量的作用域时函数级别的作用域
		// C、C#、C++、Java:在for循环内部定义的变量，只能在for循环内部访问，但是在js中，因为没有块级作用域，所以早for循环内部定义的变量在整个所在的函数内部是可以访问的。

		function f1 () {
			for (var i = 0; i < 10; i++){
				console.log(i)
			};

			console.log(i)
		};

		f1();























	</script>
</body>
</html>